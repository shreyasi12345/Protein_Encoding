import sys
import multiprocessing
from concurrent.futures import ThreadPoolExecutor
import sys
import os
import time
from datetime import datetime
import multiprocessing
from collections import defaultdict
# from numba import njit
# from numba.openmp import openmp_context as openmp
from encoders import *
import pandas as pd
import csv


def print_help():
    print("Main usage:")
    print("  Required arguments: -i <input file> -o <output file> -e <encoding> [options]")
    print(
        "  Suggested argument: --threads <integer>, default 1. Number of threads. Usually double the number of available cores.")
    print(
        "  Other arguments: --crop. Recommended for descriptors that need all sequences to have the same length. Crops all sequences to the length of the shortest sequence in the input FASTA file.")
    print("Options per encoding:")

    print("  - Binary: All sequences must be the same length.")
    print("  - TVD: All sequences must be the same length")
    print("  - SSEB: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .ss2, .spd33 or .spXout files are located, one per input sequence. .ss2 files are generated by PSIPRED, .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - SSEC")
    print(
        "    --path <dirPath>, REQUIRED. Path where .ss2, .spd33 or .spXout files are located, one per input sequence. .ss2 files are generated by PSIPRED, .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - SSPB")
    print(
        "    --path <dirPath>, REQUIRED. Path where .ss2, .spd33 or .spXout files are located, one per input sequence. .ss2 files are generated by PSIPRED, .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 1. n > 0.")
    print("  - SSPAC")
    print(
        "    --path <dirPath>, REQUIRED. Path where .ss2, .spd33 or .spXout files are located, one per input sequence. .ss2 files are generated by PSIPRED, .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 10. n > 0.")
    print("  - Disorder: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .csv disorder files are located, one per input sequence. .csv disorder files are generated by SPOT-1D.")
    print("  - DisorderB: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .csv disorder files are located, one per input sequence. .csv disorder files are generated by SPOT-1D.")
    print("  - DisorderC")
    print(
        "    --path <dirPath>, REQUIRED. Path where .csv disorder files are located, one per input sequence. .csv disorder files are generated by SPOT-1D.")
    print("  - TA: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .spd33 or .spXout files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - TAC")
    print(
        "    --path <dirPath>, REQUIRED. Path where .spd33 or .spXout files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - TAB: All sequences length must be equal or greater than n + 1.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .spd33 or .spXout files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 1. n > 0.")
    print("  - TAAC: All sequences length must be equal or greater than n + 1.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .spd33 or .spXout files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 10. n > 0.")
    print("  - ASA: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .spd33 or .spXout files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - PSSM: All sequences must be the same length.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .pssm files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - PSSMAAC")
    print(
        "    --path <dirPath>, REQUIRED. Path where .pssm files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("  - BiPSSM: All sequences length must be equal or greater than n + 1.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .pssm files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 1. n > 0.")
    print("  - PSSMAC: All sequences length must be equal or greater than n + 1.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .pssm files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 1. n > 0.")
    print("  - PPSSM: All sequences length must be equal or greater than n + 1.")
    print(
        "    --path <dirPath>, REQUIRED. Path where .pssm files are located, one per input sequence. .spd33 files are generated by SPIDER3-Single, .spXout files are generated by SPINE-X.")
    print("    --n <integer>, default: 1. n > 0.")


def print_pse_kraac_help():
    print("PseKRAAC usage: ")
    print(
        "  Required arguments: -i <input file> -o <output file> -e PseKRAAC --type <type> --subtype <subtype> --ktuple <integer> --gapLambda <integer> --raactype <integer>")
    print("Arguments: ")
    print("  --type <type>. Allowed types are 1, 2, 3A, 3B, 4, 5, 6A, 6B, 6C, 7, 8, 9, 10, 11, 12, 13, 14, 15 and 16.")
    print("  --subtype <subtype>. Allowed subtypes are g-gap and lambda-correlation.")
    print("  --ktuple <integer>. Allowed k-tuple values are 1, 2 and 3.")
    print(
        "  --gapLambda <integer>. If the subtype is g-gap, the value must be between 0 and 9. If the subtype is lambda-correlation, the value must be between 1 and 9.")
    print("  --raactype <integer>. The allowed values depend on the selected type.")
    print(help_pse_kraac())


def help_pse_kraac():
    # Provide additional help specific to PseKRAAC if needed
    return "Additional help specific to PseKRAAC if needed"


def argument_exists(arguments, option):
    return option in arguments


def get_argument(arguments, option):
    try:
        index = arguments.index(option)
        return arguments[index + 1]
    except ValueError:
        return None
    except IndexError:
        return None


def directory_exists(path):
    if os.path.exists(path):
        if os.path.isdir(path):
            return 1  # Directory exists
        else:
            print("Error:", path, "is not a directory.")
            return -1  # Path exists but is not a directory
    else:
        return 0  # Path does not exist


def is_number(number):
    if number is None:
        return False
    return number.isnumeric()


def is_float(number):
    if number[0] == '-':
        i = 1
    else:
        i = 0

    dot_count = 0
    for char in number[i:]:
        if char == '.':
            dot_count += 1
            if dot_count > 1:
                return False
        elif not char.isdigit():
            return False

    return True


def swap(a, b):
    t = a
    a = b
    b = t


def partition(names, seqs, low, high):
    pivot = seqs[high]
    i = low - 1

    for j in range(low, high):
        if len(seqs[j]) <= len(pivot):
            i += 1
            seqs[i], seqs[j] = seqs[j], seqs[i]
            names[i], names[j] = names[j], names[i]

    seqs[i + 1], seqs[high] = seqs[high], seqs[i + 1]
    names[i + 1], names[high] = names[high], names[i + 1]

    return i + 1


def quickSort(names, seqs, low, high):
    if low < high:
        pi = partition(names, seqs, low, high)
        quickSort(names, seqs, low, pi - 1)
        quickSort(names, seqs, pi + 1, high)


def quickSortTasks(low, high, names, seqs, lowLimit):
    if low < high:
        if high - low < lowLimit:
            quickSort(names, seqs, low, high)
        else:
            q = partition(names, seqs, low, high)
            multiprocessing.Process(target=quickSortTasks, args=(low, q - 1, names, seqs, lowLimit)).start()
            multiprocessing.Process(target=quickSortTasks, args=(q + 1, high, names, seqs, lowLimit)).start()


def parallelQuickSort(names, seqs, low, high):
    with ThreadPoolExecutor(max_workers=2) as executor:
        executor.submit(quickSortTasks, low, high, names, seqs, 1000 - 1)


def rtrim(s):
    s = s.rstrip()
    return s


def print_encoded(headers, seq_names, encoded, output):
    with open(output, 'w') as file:
        for header in headers:
            file.write(header + "\t")
        file.write("\n")

        for i in range(len(encoded)):
            file.write(seq_names[i] + "\t")
            for j in range(len(headers) - 1):
                file.write(f"{encoded[i][j]:.7f}\t")
            file.write("\n")


def factorial(n):
    result = 1
    while n > 1:
        result *= n
        n -= 1
    return result


def crop_sequences(seqs, length):
    for i in range(len(seqs)):
        seqs[i] = seqs[i][:length]


def read_fasta(file, names, seqs):
    with open(file, 'r') as inf:
        line = inf.readline().strip()
        while line:
            if line.startswith('>'):
                name = line[1:]
                seq = ''
                line = inf.readline().strip()
                while line and not line.startswith('>'):
                    seq += line
                    line = inf.readline().strip()
                names.append(name)
                seqs.append(seq)
            else:
                break
    return names, seqs


def read_csv(file):
    names = []
    seqs = []
    df = pd.read_csv(file)
    names = df[["Source Organism (common name)"]].values.tolist()
    seqs = df[["Sequence"]].values.tolist()
    return names, seqs


def write_to_csv(file, names, seqs, encoded):
    with open(file, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(['name', 'seq', 'encoded'])
        for i, j, k in zip(names, seqs, encoded):
            writer.writerow([i, j, k])


def main():
    start = datetime.now()
    if argument_exists(sys.argv, "--help"):
        if get_argument(sys.argv, "--help") == "PseKRAAC":
            print_pse_kraac_help()
        else:
            print_help()
        sys.exit(1)

    if len(sys.argv) < 7:
        sys.stderr.write(f"Usage: {sys.argv[0]} -i <input file> -o <output file> -e <encoding> [options]\n")
        sys.stderr.write(f"Execute {sys.argv[0]} --help argument for details.\n")
        sys.exit(1)

    dir = os.path.dirname(sys.argv[0])
    dataDir = os.path.join(dir, "data") + os.sep

    num_threads_s = get_argument(sys.argv, "--threads")
    num_threads = 1

    if num_threads_s != "":
        if not is_number(num_threads_s):
            print("Error: The --threads parameter must be a number greater than 0.")
            sys.exit(0)
        num_threads = int(num_threads_s)
        if num_threads < 0:
            print("Error: The --threads parameter must be a number greater than 0.")
            sys.exit(0)

    input = get_argument(sys.argv, "-i")
    output = get_argument(sys.argv, "-o")
    encoding = get_argument(sys.argv, "-e")
    names = []
    seqs = []

    # names, seqs = read_csv(input)
    name, seqs = read_fasta(input, names, seqs)

    num_seqs = len(names)

    if num_seqs == 0:
        print("Error: The file has no valid fasta sequences.")
        exit(0)

    reads = time.time()
    allowed = "ACDEFGHIKLMNPQRSTVWY"
    remove = time.time()
    removeCt = int((remove - reads) * 1000)

    # with openmp("parallel for num_threads(numThreads) default(none) shared(seqs, allowed) schedule(guided)"):
    # for seq in seqs:
    #     # This function is not defined in the c++ code
    #     remove_disallowed(seq, allowed)
    # Sort list by length
    # quickSort(names, seqs, 0, len(seqs) - 1)

    sort = time.time()
    sort_ct = int((sort - remove) * 1000)

    seq_names = []
    encoded = []
    headers = []
    keys = []

    ## Secondary structure (PSIPRED, SPINE-X, SPIDER3)
    if encoding == "SSEB" or encoding == "SSEC" or encoding == "SSPB" or encoding == "SSPAC":
        n = 10
        path = get_argument(sys.argv, "--path")
        if path == "":
            print(
                "Error: A path where .ss2, .spd33 or .spXout files are located is needed. Use the --path <path> argument.")
            return 0
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            return 0
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            return 0
        elif generate:
            # Generate SSE files
            pass
        typesB = {'H': [1, 0, 0], 'E': [0, 1, 0], 'C': [0, 0, 1]}
        typesC = ['H', 'E', 'C']
        headers.append("name")
        if encoding == "SSEB":
            seqLength = check_fasta_same_length(seqs)
            if seqLength == -1:
                crop = argument_exists(sys.argv, "--crop")
                if crop:
                    seqLength = get_min_sequence_length(names, seqs)
                    crop_sequences(seqs, seqLength)
                else:
                    print(
                        "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                    return 0
            for i in range(1, seqLength + 1):
                for kvp in typesB.items():
                    key = str(i) + '-' + kvp[0]
                    headers.append(key)
                    keys.append(key)
        elif encoding == "SSEC":
            for c in typesC:
                key = c
                headers.append(key)
                keys.append(key)
        elif encoding == "SSPB":
            n = 1
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                return 0
            for c in typesC:
                for d in typesC:
                    key = c + d
                    headers.append(key)
                    keys.append(key)
        elif encoding == "SSPAC":
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                return 0
            for i in range(1, n + 1):
                iString = str(i)
                for c in typesC:
                    key = iString + c
                    headers.append(key)
                    keys.append(key)

        for i in range(len(seqs)):
            file1 = open(path + "/" + names[i] + ".ss2")
            # file2 = open(path + "/" + names[i] + ".spd33")
            # file3 = open(path + "/" + names[i] + ".spXout")
            # if not file1 and not file2 and not file3:
            #     print("No predicted secondary structure files (.ss2, .spd33 or spXout) found for sequence " + names[
            #         i] + ".")
            # elif not file2 and not file3 and not file1.is_open():
            #     print("File " + names[i] + ".ss2 could not be opened.")
            # elif not file1 and not file3 and not file2.is_open():
            #     print("File " + names[i] + ".spd33 could not be opened.")
            # elif not file1 and not file2 and not file3.is_open():
            #     print("File " + names[i] + ".spXout could not be opened.")
            # elif not file1.is_open() and not file2.is_open() and not file3.is_open():
            #     print("Secondary structure files (.ss2, .spd33 or spXout) for sequence " + names[
            #         i] + " could not be opened.")
            # else:
            encodedProtein = []
            if encoding == "SSEB":
                # file1.is_open():
                encodedProtein = SSEB(seqs[i], names[i], allowed, keys, file1, typesB, "ss2")
            # elif file2.is_open():
            #     encodedProtein = SSEB(seqs[i], names[i], allowed, keys, file2, typesB, "spd33")
            # if file3.is_open():
            #     encodedProtein = SSEB(seqs[i], names[i], allowed, keys, file3, typesB, "spXout")
            elif encoding == "SSEC":
                # if file1.is_open():
                encodedProtein = SSEC(seqs[i], names[i], allowed, keys, file1, typesC, "ss2")
            # elif file2.is_open():
            #     encodedProtein = SSEC(seqs[i], names[i], allowed, keys, file2, typesC, "spd33")
            # if file3.is_open():
            #     encodedProtein = SSEC(seqs[i], names[i], allowed, keys, file3, typesC, "spXout")
            elif encoding == "SSPB":
                # if file1.is_open():
                encodedProtein = SSPB(seqs[i], names[i], allowed, keys, n, file1, typesC, "ss2")
            # elif file2.is_open():
            #     encodedProtein = SSPB(seqs[i], names[i], allowed, keys, n, file2, typesC, "spd33")
            # if file3.is_open():
            #     encodedProtein = SSPB(seqs[i], names[i], allowed, keys, n, file3, typesC, "spXout")
            elif encoding == "SSPAC":
                # if file1.is_open():
                encodedProtein = SSPAC(seqs[i], names[i], allowed, keys, n, file1, typesC, "ss2")
            # elif file2.is_open():
            #     encodedProtein = SSPAC(seqs[i], names[i], allowed, keys, n, file2, typesC, "spd33")
            # if file3.is_open():
            #     encodedProtein = SSPAC(seqs[i], names[i], allowed, keys, n, file3, typesC, "spXout")

            seq_names.append(names[i])
            encoded.append(encodedProtein)

    # Disorder
    if encoding == "Disorder":
        seqLength = check_fasta_same_length(seqs)
        if seqLength == -1:
            crop = argument_exists(sys.argv, "--crop")
            if crop:
                seqLength = get_min_sequence_length(names, seqs)
                crop_sequences(seqs, seqLength)
            else:
                print(
                    "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                exit(0)
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for loading .csv files is needed. Use the --path <path> argument.")
            exit(0)
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            exit(0)
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            exit(0)
        elif generate:
            # Generate disorder files
            pass
        headers.append("name")
        for i in range(1, seqLength + 1):
            key = str(i)
            headers.append(key)
            keys.append(key)

        for i in range(len(seqs)):
            file = open(path + "/" + names[i] + ".csv")
            if not file:
                print("File " + names[i] + ".csv does not exist.")
            elif file.is_open():
                encodedProtein = Disorder(seqs[i], names[i], allowed, keys, file)
                seq_names.append(names[i])
                encoded.append(encodedProtein)
                file.close()
            else:
                print("File " + names[i] + ".csv cannot be opened.")

    elif encoding == "DisorderC":
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for saving or loading .csv files is needed. Use the --path <path> argument.")
            exit(0)
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            exit(0)
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            exit(0)
        elif generate:
            # Generate disorder files
            pass
        headers.append("name")
        headers.append("disorder")
        headers.append("order")

        for i in range(len(seqs)):
            file = open(path + "/" + names[i] + ".csv")
            if not file:
                print("File " + names[i] + ".csv does not exist.")
            elif file.is_open():
                encodedProtein = DisorderC(seqs[i], names[i], allowed, keys, file)
                seq_names.append(names[i])
                encoded.append(encodedProtein)
                file.close()
            else:
                print("File " + names[i] + ".csv cannot be opened.")

    elif encoding == "DisorderB":
        seqLength = check_fasta_same_length(seqs)
        if seqLength == -1:
            crop = argument_exists(sys.argv, "--crop")
            if crop:
                seqLength = get_min_sequence_length(names, seqs)
                crop_sequences(seqs, seqLength)
            else:
                print(
                    "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                exit(0)
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for saving or loading .csv files is needed. Use the --path <path> argument.")
            exit(0)
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            exit(0)
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            exit(0)
        elif generate:
            # Generate disorder files
            pass
        headers.append("name")
        for i in range(1, seqLength + 1):
            key = str(i)
            headers.append(key + "-order")
            keys.append(key + "-order")
            headers.append(key + "-disorder")
            keys.append(key + "-disorder")

        for i in range(len(seqs)):
            file = open(path + "/" + names[i] + ".csv")
            if not file:
                print("File " + names[i] + ".csv does not exist.")
            elif file.is_open():
                encodedProtein = DisorderB(seqs[i], names[i], allowed, keys, file)
                seq_names.append(names[i])
                encoded.append(encodedProtein)
                file.close()
            else:
                print("File " + names[i] + ".csv cannot be opened.")
    # Torsion (Spine-X)
    elif encoding == "TA" or encoding == "TAC" or encoding == "TAB" or encoding == "TAAC":
        n = 10
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for loading .spd33 or .spXout files is needed. Use the --path <path> argument.")
            return 0
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            return 0
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            return 0
        elif generate:
            # Generate disorder files
            pass
        headers.append("name")
        if encoding == "TA":
            seqLength = check_fasta_same_length(seqs)
            if seqLength == -1:
                crop = argument_exists(sys.argv, "--crop")
                if crop:
                    seqLength = get_min_sequence_length(names, seqs)
                    crop_sequences(seqs, seqLength)
                else:
                    print(
                        "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                    return 0
            for i in range(1, seqLength + 1):
                key = str(i)
                headers.append(key + "-phi")
                keys.append(key + "-phi")
                headers.append(key + "-psi")
                keys.append(key + "-psi")
        elif encoding == "TAC":
            headers.append("phiSin")
            headers.append("phiCos")
            headers.append("psiSin")
            headers.append("psiCos")
            keys.append("phiSin")
            keys.append("phiCos")
            keys.append("psiSin")
            keys.append("psiCos")
        elif encoding == "TAB":
            n = 1
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                return 0
            headers.append("phiSin-phiSin")
            headers.append("phiSin-phiCos")
            headers.append("phiSin-psiSin")
            headers.append("phiSin-psiCos")
            headers.append("phiCos-phiCos")
            headers.append("phiCos-psiSin")
            headers.append("phiCos-psiCos")
            headers.append("psiSin-psiSin")
            headers.append("psiSin-psiCos")
            headers.append("psiCos-psiCos")
            keys.append("phiSin-phiSin")
            keys.append("phiSin-phiCos")
            keys.append("phiSin-psiSin")
            keys.append("phiSin-psiCos")
            keys.append("phiCos-phiCos")
            keys.append("phiCos-psiSin")
            keys.append("phiCos-psiCos")
            keys.append("psiSin-psiSin")
            keys.append("psiSin-psiCos")
            keys.append("psiCos-psiCos")
        elif encoding == "TAAC":
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    return 0
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                return 0
            for i in range(1, n + 1):
                key = str(i)
                headers.append(key + "-phiSin")
                headers.append(key + "-phiCos")
                headers.append(key + "-psiSin")
                headers.append(key + "-psiCos")
                keys.append(key + "-phiSin")
                keys.append(key + "-phiCos")
                keys.append(key + "-psiSin")
                keys.append(key + "-psiCos")

        for i in range(len(seqs)):
            # TODO: check if .spd33 or .spxout files exist first and then open

            # file1 = open(path + "/" + names[i] + ".spd33")
            # file2 = open(path + "/" + names[i] + ".spXout")
            # if not file1 and not file2:
            #     print("No torsion angles files (.spd3 or spXout) found for sequence " + names[i] + ".")
            # elif not file1 and not file2.is_open():
            #     print("File " + names[i] + ".spd33 could not be opened.")
            # elif not file2 and not file1.is_open():
            #     print("File " + names[i] + ".spXout could not be opened.")
            # else:
            #     encodedProtein = []
            #     if file1.is_open():
            #         if encoding == "TA":
            #             encodedProtein = TA(seqs[i], names[i], allowed, keys, file1, "spd33")
            #         if encoding == "TAC":
            #             encodedProtein = TAC(seqs[i], names[i], allowed, keys, file1, "spd33")
            #         if encoding == "TAB":
            #             encodedProtein = TAB(seqs[i], names[i], allowed, keys, n, file1, "spd33")
            #         if encoding == "TAAC":
            #             encodedProtein = TAAC(seqs[i], names[i], allowed, keys, n, file1, "spd33")
            #     else:
            #         if encoding == "TA":
            #             encodedProtein = TA(seqs[i], names[i], allowed, keys, file2, "spXout")
            #         if encoding == "TAC":
            #             encodedProtein = TAC(seqs[i], names[i], allowed, keys, file2, "spXout")
            #         if encoding == "TAB":
            #             encodedProtein = TAB(seqs[i], names[i], allowed, keys, n, file2, "spXout")
            #         if encoding == "TAAC":
            #             encodedProtein = TAAC(seqs[i], names[i], allowed, keys, n, file2, "spXout")

            file2 = open(path + "/" + names[i] + ".spXout")
            if encoding == "TA":
                encodedProtein = TA(seqs[i], names[i], allowed, keys, file2, "spXout")
            if encoding == "TAC":
                encodedProtein = TAC(seqs[i], names[i], allowed, keys, file2, "spXout")
            if encoding == "TAB":
                encodedProtein = TAB(seqs[i], names[i], allowed, keys, n, file2, "spXout")
            if encoding == "TAAC":
                encodedProtein = TAAC(seqs[i], names[i], allowed, keys,n, file2, "spXout")

            seq_names.append(names[i])
            encoded.append(encodedProtein)

    elif encoding == "ASA":
        seq_length = check_fasta_same_length(seqs)
        if seq_length == -1:
            crop = argument_exists(sys.argv, "--crop")
            if crop:
                seq_length = get_min_sequence_length(names, seqs)
                crop_sequences(seqs, seq_length)
            else:
                print(
                    "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                sys.exit(0)
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for loading .spd33 or .spXout files is needed. Use the --path <path> argument.")
            sys.exit(0)
        generate = argument_exists(sys.argv, "--generate")
        path_exists = directory_exists(path)
        if path_exists == -1:
            sys.exit(0)
        elif not generate and path_exists == 0:
            print("Error: The path does not exist.")
            sys.exit(0)
        elif generate:
            # Generate ASA files
            pass
        headers = ["name"]
        for i in range(1, seq_length + 1):
            key = str(i)
            headers.append(key)
            keys.append(key)

        # Assuming a parallel processing context similar to OpenMP in Python (e.g., using multiprocessing)
        for i in range(len(seqs)):
            with open(os.path.join(path, f"{names[i]}.spd33"), 'r') as file1, \
                    open(os.path.join(path, f"{names[i]}.spXout"), 'r') as file2:
                if not file1 and not file2:
                    print(f"No torsion angles files (.spd3 or spXout) found for sequence {names[i]}.")
                elif not file1 and file2:
                    print(f"File {names[i]}.spd33 could not be opened.")
                elif not file2 and file1:
                    print(f"File {names[i]}.spXout could not be opened.")
                else:
                    encoded_protein = ASA(seqs[i], names[i], allowed, keys, file1 if file1 else file2,
                                          "spd33" if file1 else "spXout")
                    seq_names.append(names[i])
                    encoded.append(encoded_protein)
    # PSSM(blastpgp)
    elif encoding == "PSSM" or encoding == "PSSMAAC" or encoding == "BiPSSM" or encoding == "PSSMAC" or encoding == "PPSSM":
        n = 30
        path = get_argument(sys.argv, "--path")
        if path == "":
            print("Error: A path for saving or loading PSSM files is needed. Use the --path <path> argument.")
            exit(0)
        generate = argument_exists(sys.argv, "--generate")
        pathExists = directory_exists(path)
        if pathExists == -1:
            exit(0)
        elif not generate and pathExists == 0:
            print("Error: The path does not exist.")
            exit(0)
        elif generate:
            # Generate PSSM files
            pass
        orderString = "ARNDCQEGHILKMFPSTWYV"
        headers.append("name")
        if encoding == "PSSM":
            seqLength = check_fasta_same_length(seqs)
            if seqLength == -1:
                crop = argument_exists(sys.argv, "--crop")
                if crop:
                    seqLength = get_min_sequence_length(names, seqs)
                    crop_sequences(seqs, seqLength)
                else:
                    print(
                        "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                    exit(0)
            for i in range(seqLength):
                for c in orderString:
                    key = str(i)
                    key += c
                    headers.append(key)
                    keys.append(key)
        elif encoding == "PSSMAAC":
            for c in orderString:
                aa = c
                headers.append(aa)
                keys.append(aa)
        elif encoding == "BiPSSM":
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
            for c in orderString:
                for d in orderString:
                    key = c
                    key += d
                    headers.append(key)
                    keys.append(key)
        elif encoding == "PSSMAC":
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                exit(0)
            for c in orderString:
                for i in range(1, n + 1):
                    key = str(i)
                    key += c
                    headers.append(key)
                    keys.append(key)
        elif encoding == "PPSSM":
            nS = get_argument(sys.argv, "--n")
            if nS != "":
                if not is_number(nS):
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
                n = int(nS)
                if n < 1:
                    print("Error: The n value must be a number greater or equal than 1.")
                    exit(0)
            minLength = get_min_sequence_length(names, seqs)
            if minLength < n + 1:
                print("Error: All sequences length must be equal or greater than n + 1.")
                exit(0)
            for c in orderString:
                key = "S" + c
                headers.append(key)
                keys.append(key)
            for c in orderString:
                key = "R" + c
                headers.append(key)
                keys.append(key)
        for i in range(len(seqs)):
            file = open(path + "/" + names[i] + ".pssm")
            if not file:
                print("File " + names[i] + ".pssm does not exist.")
            elif file.is_open():
                encodedProtein = []
                # if encoding == "PSSM":
                #     encodedProtein = PSSM(seqs[i], names[i], orderString, keys, file)
                # elif encoding == "PSSMAAC":
                #     encodedProtein = PSSMAAC(seqs[i], names[i], keys, orderString, file)
                if encoding == "BiPSSM":
                    encodedProtein = BiPSSM(seqs[i], names[i], keys, orderString, n, file)
                elif encoding == "PSSMAC":
                    encodedProtein = PSSMAC(seqs[i], names[i], keys, orderString, n, file)
                elif encoding == "PPSSM":
                    encodedProtein = PPSSM(seqs[i], names[i], keys, orderString, n, file)
                seq_names.append(names[i])
                encoded.append(encodedProtein)
                file.close()
            else:
                print("File " + names[i] + ".pssm cannot be opened.")
    # TVD
    elif encoding == "TVD":
        seq_length = check_fasta_same_length(seqs)
        if seq_length == -1:
            crop = "--crop" in sys.argv
            if crop:
                seq_length = get_min_sequence_length(names, seqs)
                crop_sequences(seqs, seq_length)
            else:
                print(
                    "Error: All sequences must have the same length. You can use the --crop argument, so it crops the sequences automatically.")
                return 0

        # The vectors are in the following order:
        # Hydrophobic, positive, negative, polar, charged, small, tiny, aliphatic, aromatic, proline
        tvd = {
            'A': [1, 0, 0, 0, 0, 1, 1, 0, 0, 0],
            'C': [1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            'D': [0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
            'E': [0, 0, 1, 1, 1, 0, 0, 0, 0, 0],
            'F': [1, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            'G': [1, 0, 0, 0, 0, 1, 1, 0, 0, 0],
            'H': [1, 1, 0, 1, 1, 0, 0, 0, 1, 0],
            'I': [1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            'K': [1, 1, 0, 1, 1, 0, 0, 0, 0, 0],
            'L': [1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            'M': [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            'N': [0, 0, 0, 1, 0, 1, 0, 0, 0, 0],
            'P': [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Q': [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            'R': [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],
            'S': [0, 0, 0, 1, 0, 1, 1, 0, 0, 0],
            'T': [1, 0, 0, 1, 0, 1, 0, 0, 0, 0],
            'V': [1, 0, 0, 0, 0, 1, 0, 1, 0, 0],
            'W': [1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            'Y': [1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
        }

        headers = ["name"]
        keys = []
        for i in range(seq_length):
            key = str(i) + '-'
            headers.extend(
                [key + "hydrophobic", key + "positive", key + "negative", key + "polar", key + "charged", key + "small",
                 key + "tiny", key + "aliphatic", key + "aromatic", key + "proline"])
            keys.extend(
                [key + "hydrophobic", key + "positive", key + "negative", key + "polar", key + "charged", key + "small",
                 key + "tiny", key + "aliphatic", key + "aromatic", key + "proline"])

        # Assuming TVD is a function defined elsewhere that computes the encoding
        seq_names = []
        encoded = []
        for i, seq in enumerate(seqs):
            encoded_protein = TVD(seq, allowed, keys, tvd)
            seq_names.append(names[i])
            encoded.append(encoded_protein)

    write_to_csv(output, names, seqs, encoded)


if __name__ == "__main__":
    main()
    # print_help()
    # print_pse_kraac_help()
